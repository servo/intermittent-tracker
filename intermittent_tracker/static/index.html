<!doctype html><meta charset="utf-8">
<link rel="stylesheet" href="/static/style.css">
<script src="https://unpkg.com/vue@3.2.47"></script>
<main>
    <h2>recent unexpected results</h2>
    <Recent branch="auto"></Recent>
</main>
<script type="text/x-template" id="Recent">
    <h3>{{ branch }} branch as of <Time v-if="lastUpdate != null" :t="lastUpdate"></Time></h3>
    <table class="AttemptList" border="1" width="100%">
        <colgroup>
            <col width="0*">
            <col width="0*">
            <col>
            <col width="0*">
            <col width="0*">
        </colgroup>
        <tr>
            <th>branch</th>
            <th>time</th>
            <th>test</th>
            <th>build</th>
            <th>pull</th>
        </tr>
        <tr v-for="attempt in attempts">
            <td>{{ attempt.branch }}</td>
            <td><Time :t="attempt.time" :relative-to="lastUpdate"></Time></td>
            <td>{{ attempt.path }}</td>
            <td><a v-if="attempt.build_url" :href="attempt.build_url" target="_blank">{{ attempt.build_url.split("/").at(-1) }}</a></td>
            <td><a v-if="attempt.pull_url" :href="attempt.pull_url" target="_blank">{{ attempt.pull_url.split("/").at(-1) }}</a></td>
        </tr>
    </table>
</script>
<script type="text/x-template" id="Time">
    <time v-if="relativeTo != null" :datetime="iso" :title="iso">{{ relativeText }}</time>
    <time v-else :datetime="iso" :title="iso">{{ absoluteText }}</time>
</script>
<script>
    const Recent = {
        template: "#Recent",
        props: {
            branch: {type: String, required: true},
        },
        data() {
            return {
                since: null,
                attempts: [],
                lastUpdate: null,
            };
        },
        mounted() {
            this.update();
        },
        methods: {
            async update() {
                try {
                    const result = await fetchRecent(this.since, {branch: this.branch});
                    this.since = result.length > 0 ? result[0].time : 0;
                    this.attempts = mergeOldAttempts(coalesceSubtestAttempts(result), this.attempts);
                    this.lastUpdate = Date.now() / 1000;
                } catch (e) {
                    console.error(e);
                } finally {
                    setTimeout(this.update, 1000);
                }
            },
        },
    };

    const Time = {
        template: "#Time",
        props: {
            t: {type: Number, required: true},
            relativeTo: Number,
        },
        computed: {
            iso() {
                return new Date(this.t * 1000).toISOString();
            },
            relativeText() {
                const now = this.relativeTo;
                return now - this.t >= 86400 ? `${Math.trunc((now - this.t) / 86400)}d`
                    : now - this.t >= 3600 ? `${Math.trunc((now - this.t) / 3600)}h`
                    : now - this.t >= 60 ? `${Math.trunc((now - this.t) / 60)}m`
                    : `${Math.trunc(now - this.t)}s`;
            },
            absoluteText() {
                return this.iso.slice(0,-5).replace("T"," ");
            },
        },
    };

    async function fetchRecent(since = null, {branch = "auto"}) {
        const params = new URLSearchParams();
        if (branch != null)
            params.set("branch", branch);
        if (since != null)
            params.set("since", since);
        const response = await fetch(`/dashboard/attempts?${params}`);
        if (!response.ok)
            throw new Error(response);
        return response.json();
    }

    function coalesceSubtestAttempts(result) {
        let i = 0;
        while (i < result.length) {
            if (i > 0 && result[i].path == result[i-1].path
                && result[i].build_url == result[i-1].build_url
                && result[i].time == result[i-1].time) {
                result[i-1].subtests.push(result[i]);
                result.splice(i, 1);
            } else {
                if (result[i].subtest != null)
                    result[i].subtests = [{...result[i]}];
                else
                    result[i].subtests = [];
                i += 1;
            }
        }
        return result;
    }

    function mergeOldAttempts(result, old) {
        for (const attempt of old)
            if (!result.some(x => x.rowid == attempt.rowid))
                result.push(attempt);
        return result;
    }

    const app = Vue.createApp();
    app.component("Recent", Recent);
    app.component("Time", Time);
    app.mount("main");
</script>
